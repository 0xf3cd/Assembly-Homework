DATA	SEGMENT
ALL	DB	50			;记录所有有效成绩个数
GRADES	DB	50 DUP(0)
SAVER	DB	12 DUP(1)
NOTICE	DB	"If the student was absent from the test, please press 'Enter' directly.$"
CR_LF	DB	10,13,'$'
SPACES	DB	"  $"
GRADE_5	DB	0
GRADE_4	DB	0
GRADE_3	DB	0
GRADE_2	DB	0
GRADE_0	DB	0			
LOWEST	DB	100
HIGHEST	DB	0
AVG_1	DB	?
AVG_2	DB	?
;AVG_1.AVG_2为整个数
MARK_5	DB	'The number of students who got 5 was: $'
MARK_4	DB	'The number of students who got 4 was: $'
MARK_3	DB	'The number of students who got 3 was: $'
MARK_2	DB	'The number of students who got 2 was: $'
MARK_0	DB	'The number of students who got 0 was: $'
MARK_L	DB	'The lowest grades were: $'
MARK_H	DB	'The highest grades were: $'
MARK_A	DB	'The average grades were: $'
DATA	ENDS

CODE	SEGMENT
	ASSUME	CS:CODE, DS:DATA
	
MAIN	PROC	FAR
	PUSH	DS
	MOV	AX, 0
	PUSH	AX			;DOS压栈
	
	MOV	AX, DATA
	MOV	DS, AX
	
	CALL	INPUT			;输入成绩
	CALL	ANALYZE			;分析成绩，计算最高分最低分平均分等
	CALL	OUTPUT_RESULT		;输出结果
	RET				;RETURN
MAIN	ENDP

CRLF	PROC	NEAR			;换行
	PUSH	AX
	PUSH	DX
	
	MOV	AH, 09H
	MOV	DX, OFFSET CR_LF
	INT	21H
	
	POP	DX
	POP	AX
	RET
CRLF	ENDP

SEPARATE	PROC	NEAR
	PUSH	AX
	PUSH	DX
	
	MOV	AH, 09H
	MOV	DX, OFFSET SPACES
	INT	21H
	
	POP	DX
	POP	AX
	RET
SEPARATE	ENDP

OUTPUT_CX	PROC	NEAR		;输出CX中储存的十进制数
	PUSH	AX
	PUSH	BX
	PUSH	CX
	PUSH	DX
	
	MOV	AX, CX
	MOV	BL, 10
	DIV	BL			;AL->十位，AH->个位
	
	MOV	BH, AH
	MOV	DL, AL
	ADD	DL, '0'
	MOV	AH, 02H
	INT	21H
	MOV	DL, BH
	ADD	DL, '0'
	INT	21H
	
	POP	DX
	POP	CX
	POP	BX
	POP	AX
	RET	
OUTPUT_CX	ENDP

INPUT	PROC	NEAR			;输入成绩
	MOV	SAVER, 10		;缓冲区长度为10
	CALL	CRLF
	MOV	DX, OFFSET NOTICE
	MOV	AH, 09H
	INT	21H
	CALL	CRLF			;输出提示性语句，缺考学生输入成绩时直接按下回车
	
	MOV	CX, 1
	MOV	BX, OFFSET GRADES
	MOV	DX, OFFSET SAVER
START_OF_LOOP:
	CALL	OUTPUT_CX		;输出CX
	CALL	SEPARATE
	INC	CX
	
	MOV	AH, 0AH
	INT	21H			;输入成绩
	
	MOV	SI, OFFSET SAVER
	INC	SI
	PUSH	AX			;借用AX
	MOV	AL, BYTE PTR [SI]
	MOV	AH, 0
	MOV	BP, AX			;BP储存了字符数
	POP	AX			;AX复位
	CMP	BYTE PTR [SI], 0
	JNE	GET_GRADES
	DEC	ALL			;直接按下回车，代表缺考，有效人数减去1
	JMP	JUDGE_OF_LOOP		;继续下一次循环
GET_GRADES:
	PUSH	BX
	PUSH	CX
	
	MOV	AX, 0
	MOV	CL, 10
	MOV	BX, OFFSET SAVER
	ADD	BX, 2			;BX指向存储输入成绩的内存区域
AGAIN_OF_GET_GARDES:
	SUB	BYTE PTR [BX], '0'
	MUL	CL
	ADD	AL, BYTE PTR [BX]
	ADC	AH, 0
	INC	BX
	DEC	BP
	CMP	BP, 0
	JNE	AGAIN_OF_GET_GARDES
	
	POP	CX
	POP	BX
	;循环结束，AL储存了成绩
	
	MOV	BYTE PTR [BX], AL
	INC	BX
JUDGE_OF_LOOP:
	CALL	CRLF
	CMP	CX, 51
	JL	START_OF_LOOP		;如果CX>50则结束循环
	;JMP	END_OF_INPUT	
END_OF_INPUT:
	RET
	;结束时，ALL记录了有效人数，GRADES数组记录了成绩
INPUT	ENDP

ANALYZE	PROC	NEAR
	MOV	CH, 0
	MOV	CL, ALL
	MOV	BX, OFFSET GRADES
	MOV	AX, 0
FIND_HIGHEST:
	MOV	DH, BYTE PTR [BX]
	CMP	DH, HIGHEST
	JLE	FIND_LOWEST		;发现比当前最高分高的，则修改
	MOV	HIGHEST, DH
FIND_LOWEST:
	;MOV	DH, [BX]
	CMP	DH, LOWEST
	JGE	SUM_UP			;发现比当前最低分低的，则修改
	MOV	LOWEST, DH
SUM_UP:
	CALL	RANK			;成绩分等级
	ADD	AL, BYTE PTR [BX]
	ADC	AH, 0
	INC	BX
	DEC	CX
	CMP	CX, 0
	JNE	FIND_HIGHEST
	;循环结束,AX中储存了总分
	
	MOV	BH, 10
	MOV	BL, ALL
	DIV	BL
	
	MOV	AVG_1, AL
	;接下来考虑小数部分
NOT_ZERO:
	MOV	AL, AH
	MOV	AH, 0
	;BL->ALL BH->10
	MUL	BH
	DIV	BL
	MOV	CH, AH			;取小数点后第一位于CH中
	MOV	AH, 0
	MUL	BH
	DIV	BL
	MOV	CL, AH			;取小数点后第二位于CL中
	CMP	CL, 5
	JL	END_OF_ANALYZE		;不需要四舍五入
	INC	CH
END_OF_ANALYZE:
	MOV	AVG_2, CH
	RET	
ANALYZE	ENDP

RANK	PROC	NEAR			;将[BX]中储存的成绩归入优良中及格不及格五档
RANK_5:
	CMP	BYTE PTR [BX], 90
	JL	RANK_4
	INC	GRADE_5
	JMP	END_OF_RANK
RANK_4:
	CMP	BYTE PTR [BX], 80
	JL	RANK_3
	INC	GRADE_4
	JMP	END_OF_RANK
RANK_3:
	CMP	BYTE PTR [BX], 70
	JL	RANK_2
	INC	GRADE_3
	JMP	END_OF_RANK
RANK_2:
	CMP	BYTE PTR [BX], 60
	JL	RANK_0
	INC	GRADE_2
	JMP	END_OF_RANK
RANK_0:
	INC	GRADE_0
	JMP	END_OF_RANK
END_OF_RANK:
	RET
RANK	ENDP

OUTPUT_RESULT	PROC	NEAR
	CALL	CRLF

	MOV	AH, 09H
	MOV	DX, OFFSET MARK_5
	INT	21H
	MOV	CH, 0
	MOV	CL, GRADE_5
	CALL	OUTPUT_CX
	CALL	CRLF

	MOV	AH, 09H
	MOV	DX, OFFSET MARK_4
	INT	21H
	MOV	CH, 0
	MOV	CL, GRADE_4
	CALL	OUTPUT_CX
	CALL	CRLF

	MOV	AH, 09H
	MOV	DX, OFFSET MARK_3
	INT	21H
	MOV	CH, 0
	MOV	CL, GRADE_3
	CALL	OUTPUT_CX
	CALL	CRLF

	MOV	AH, 09H
	MOV	DX, OFFSET MARK_2
	INT	21H
	MOV	CH, 0
	MOV	CL, GRADE_2
	CALL	OUTPUT_CX
	CALL	CRLF

	MOV	AH, 09H
	MOV	DX, OFFSET MARK_0
	INT	21H
	MOV	CH, 0
	MOV	CL, GRADE_0
	CALL	OUTPUT_CX
	CALL	CRLF

	MOV	AH, 09H
	MOV	DX, OFFSET MARK_L
	INT	21H
	MOV	CH, 0
	MOV	CL, LOWEST
	CALL	OUTPUT_CX
	CALL	CRLF

	MOV	AH, 09H
	MOV	DX, OFFSET MARK_H
	INT	21H
	MOV	CH, 0
	MOV	CL, HIGHEST
	CALL	OUTPUT_CX
	CALL	CRLF

	MOV	AH, 09H
	MOV	DX, OFFSET MARK_0
	INT	21H
	MOV	CH, 0
	MOV	CL, AVG_1
	CALL	OUTPUT_CX
	MOV	AH, 02H
	MOV	DL, '.'
	INT	21H
	MOV	DL, '0'
	ADD	DL, AVG_2
	INT	21H
	CALL	CRLF

	RET
OUTPUT_RESULT	ENDP

CODE	ENDS
	END	MAIN