DATA	SEGMENT
BUFFER	DB	52 DUP (?)
NOTICE	DB	"Please input an expression.", 10, 13, "such as 'S=4+6*9-1+8/5'", 10, 13, '$'
CR_LF	DB	10, 13, '$'
NO	DB	1
N1	DB	0
N2	DB	0
D1	DB	1
D2	DB	1
DCM	DB	0				;DCM->DECIMAL->小数
S_BX	DB	1
S_DCM	DB	1
;以上两个变量代表了整数和小数部分的符号 1正 0零 -1负
DATA	ENDS

CODE	SEGMENT
	ASSUME CS:CODE, DS:DATA
MAIN	PROC	FAR
	PUSH	DS
	MOV	AX, 0
	PUSH	AX
	
	MOV	AX, DATA
	MOV	DS, AX
	
	CALL	INPUT
	CALL	OUTPUT_TITLE
	CALL	CALCULATE
	CALL	OUTPUT
	
	RET
MAIN	ENDP

INPUT	PROC	NEAR
	PUSH	AX
	PUSH	DX
	
	MOV	AH, 09H
	MOV	DX, OFFSET NOTICE
	INT	21H
	
	CALL	CRLF				;为了美观，换行
	
	MOV	DX, OFFSET BUFFER
	MOV	BYTE PTR [BUFFER], 50		;设定缓冲区长度
	MOV	AH, 0AH
	INT	21H
	
	CALL	CRLF
	CALL	CRLF
	
	POP	DX
	POP	AX
	RET
INPUT	ENDP

FIND_FIRST	PROC	NEAR
	PUSH	AX
	;PUSH	BX
	PUSH	DX
	
	MOV	BX, OFFSET BUFFER
	ADD	BX, 2				;此刻BX指向输入的表达式的第一个字符
	
	;MOV	AH, 02H
NEXT_CHAR:
	;MOV	DL, BYTE PTR [BX]
	;INT	21H
	
	CMP	DL, '='
	JE	END_OF_FIND_FIRST
	INC	BX
	JMP	NEXT_CHAR
	
END_OF_FIND_FIRST:
	INC	BX
	POP	DX
	;POP	BX				;此时BX指向等号后的第一个字符
	POP	AX
	RET
FIND_FIRST	ENDP

OUTPUT_TITLE	PROC	NEAR
	PUSH	AX
	;PUSH	BX
	PUSH	DX
	
	MOV	BX, OFFSET BUFFER
	ADD	BX, 2				;此刻BX指向输入的表达式的第一个字符
	
	MOV	AH, 02H
OUTPUT_ONE_CHAR:
	MOV	DL, BYTE PTR [BX]
	INT	21H
	
	CMP	DL, '='
	JE	END_OF_OUTPUT_TITLE
	INC	BX
	JMP	OUTPUT_ONE_CHAR
	
END_OF_OUTPUT_TITLE:
	INC	BX
	POP	DX
	;POP	BX				;此时BX指向等号后的第一个字符
	POP	AX
	RET
OUTPUT_TITLE	ENDP

CRLF	PROC	NEAR
	PUSH	AX
	PUSH	DX
	
	MOV	AH, 09H
	MOV	DX, OFFSET CR_LF
	INT	21H
	
	POP	DX
	POP	AX
	RET
CRLF	ENDP

CALCULATE	PROC	NEAR
	MOV	SI, OFFSET BUFFER
	INC	SI
	MOV	CH, 0
	MOV	CL, BYTE PTR [SI]		;CX储存了字符个数
	MOV	DI, OFFSET BUFFER
	ADD	DI, 2
	ADD	DI, CX
	DEC	DI				;DI为末尾字符的地址
	PUSH	BX				;储存等号后第一个字符的地址
	;PUSH	DI				;储存末尾字符的地址
	
	DEC	BX
REFORM:;'0' -> 0
	INC	BX
	
	CMP	BYTE PTR [BX], '0'
	JGE	MAYBE_NUM
	JMP	REFORM_AGAIN
MAYBE_NUM:
	CMP	BYTE PTR [BX], '9'
	JLE	IS_NUM
	JMP	REFORM_AGAIN
IS_NUM:
	SUB	BYTE PTR [BX], '0'
REFORM_AGAIN:
	CMP	BX, DI
	JE	END_OF_REFORM
	JMP	REFORM
END_OF_REFORM:
	POP	BX				;BX复位
	PUSH	BX

;计算整数部分
	CALL	CAL_MULTIPLY_AND_DIVICE
	CALL	CAL_MULTIPLY_AND_DIVICE
	CALL	CAL_MULTIPLY_AND_DIVICE
	CALL	CAL_MULTIPLY_AND_DIVICE
	CALL	CAL_ADD_AND_MINUS
	CALL	CAL_ADD_AND_MINUS
	CALL	CAL_ADD_AND_MINUS
	CALL	CAL_ADD_AND_MINUS
;计算小数部分
	CALL	CAL_DECIMAL
	
	POP	BX
	RET
CALCULATE	ENDP 

MAKE_MINUSONE_DISAPPEAR	PROC	NEAR
	; BI -> DI
	PUSH	BX
	PUSH	SI
	PUSH	AX
	
	DEC	BX
MAKE:	
	INC	BX
	CMP	BYTE PTR [BX], -1
	JE	FIND_ZERO
	JMP	MAKE
FIND_ZERO:
	MOV	SI, BX
	ADD	SI, 2
MOVE_ONE_CHAR:
	MOV	AL, BYTE PTR [SI]
	MOV	BYTE PTR [BX], AL
	CMP	SI, DI
	JGE	END_OF_MAKE_ZERO_DISAPPEAR
	INC	BX
	INC	SI
	JMP	MOVE_ONE_CHAR
END_OF_MAKE_ZERO_DISAPPEAR:
	SUB	DI, 2
	
	POP	AX
	POP	SI
	POP	BX
	RET
MAKE_MINUSONE_DISAPPEAR	ENDP

CAL_MULTIPLY_AND_DIVICE	PROC	NEAR
	;默认 BX -> DI
	PUSH	BX
	
	DEC	BX
FIND_MULTIPLY_AND_DIVIDE:
	INC	BX
	CMP	BYTE PTR [BX], '*'
	JE	IS_MULTIPLY
	CMP	BYTE PTR [BX], '/'
	JE	IS_DIVIDE
	JMP	FIND_MULTIPLY_AND_DIVIDE_AGAIN
IS_MULTIPLY:
	MOV	AH, 0
	MOV	AL, BYTE PTR [BX-1]
	MOV	CL, BYTE PTR [BX+1]
	MUL	CL
	MOV	BYTE PTR [BX-1], AL
	MOV	BYTE PTR [BX], -1
	MOV	BYTE PTR [BX+1], -1
	
	POP	BX
	PUSH	BX
	
	CALL	MAKE_MINUSONE_DISAPPEAR
	
	JMP	END_OF_FIND_MULTIPLY_AND_DIVIDE
	
IS_DIVIDE:
	MOV	AH, 0
	MOV	AL, BYTE PTR [BX-1]
	MOV	CL, BYTE PTR [BX+1]
	DIV	CL
	;AL商，AH余数
	MOV	BYTE PTR [BX-1], AL
	MOV	BYTE PTR [BX], -1
	MOV	BYTE PTR [BX+1], -1
	
	CMP	NO, 1
	JE	FIRST
	JMP	SECOND
FIRST:
	MOV	NO, 2
	;MOV	AL, BYTE PTR [BX+1]
	MOV	D1, CL
	MOV	N1, AH
	CMP	BYTE PTR [BX-2], '-'
	JNE	END_OF_ONE_DIVIDE
	NEG	N1
	JMP	END_OF_ONE_DIVIDE
SECOND:
	;MOV	AL, BYTE PTR [BX+1]
	MOV	D2, CL
	MOV	N2, AH
	CMP	BYTE PTR [BX-2], '-'
	JNE	END_OF_ONE_DIVIDE
	NEG	N1
	JMP	END_OF_ONE_DIVIDE
END_OF_ONE_DIVIDE:
	POP	BX
	PUSH	BX
	
	CALL	MAKE_MINUSONE_DISAPPEAR
	
	JMP	END_OF_FIND_MULTIPLY_AND_DIVIDE
	
FIND_MULTIPLY_AND_DIVIDE_AGAIN:
	CMP	BX, DI
	JE	END_OF_FIND_MULTIPLY_AND_DIVIDE
	JMP	FIND_MULTIPLY_AND_DIVIDE
END_OF_FIND_MULTIPLY_AND_DIVIDE:
	POP	BX
	RET
CAL_MULTIPLY_AND_DIVICE	ENDP
	
CAL_ADD_AND_MINUS	PROC	NEAR
	;默认 BX -> DI
	PUSH	BX
	
	DEC	BX
FIND_ADD_AND_MINUS:
	INC	BX
	CMP	BYTE PTR [BX], '+'
	JE	IS_ADD
	CMP	BYTE PTR [BX], '-'
	JE	IS_MINUS
	JMP	FIND_ADD_AND_MINUS_AGAIN
IS_ADD:
	MOV	AH, 0
	MOV	AL, BYTE PTR [BX-1]
	MOV	CH, 0
	MOV	CL, BYTE PTR [BX+1]
	ADD	AX, CX
	MOV	BYTE PTR [BX-1], AL
	MOV	BYTE PTR [BX], -1
	MOV	BYTE PTR [BX+1], -1
	
	POP	BX
	PUSH	BX
	
	CALL	MAKE_MINUSONE_DISAPPEAR
	
	JMP	FIND_ADD_AND_MINUS_AGAIN
	
IS_MINUS:
	MOV	AH, 0
	MOV	AL, BYTE PTR [BX-1]
	MOV	CH, 0
	MOV	CL, BYTE PTR [BX+1]
	SUB	AX, CX
	MOV	BYTE PTR [BX-1], AL
	MOV	BYTE PTR [BX], -1
	MOV	BYTE PTR [BX+1], -1
	
	POP	BX
	PUSH	BX
	
	CALL	MAKE_MINUSONE_DISAPPEAR
	
	JMP	FIND_ADD_AND_MINUS_AGAIN
	
FIND_ADD_AND_MINUS_AGAIN:
	CMP	BX, DI
	JE	END_OF_FIND_ADD_AND_MINUS
	JMP	FIND_ADD_AND_MINUS
END_OF_FIND_ADD_AND_MINUS:
	POP	BX
	RET
CAL_ADD_AND_MINUS	ENDP

CAL_DECIMAL	PROC	NEAR
	PUSH	AX
	PUSH	CX
	PUSH	DX
	PUSH	BX
	
	MOV	CH, D1
	MOV	AH, 0
	MOV	AL, D2
	IMUL	CH
	MOV	CH, 0
	MOV	CL, AL			;CL保存了D1*D2的值
	MOV	AH, 0
	MOV	AL, N1
	MOV	DH, D2
	IMUL	DH
	MOV	BH, AL			;BH保存了N1*D2的值
	MOV	AH, 0
	MOV	AL, N2
	MOV	DH, D1
	IMUL	DH
	ADD	AL,BH			;AL保存了N1*D2+N2*D1的值
	CBW
	
	
	;AX/CL
	CMP	AX, 0
	JGE	DCM_MORE_THAN_ZERO
	;小数部分<0
	MOV	S_DCM, -1
	NEG	AX
	IDIV	CL
	;AL商，AH余数
	SUB	BYTE PTR [BX], AL
	MOV	AL, AH
	CBW
	MOV	CH, 10
	IMUL	CH
	IDIV	CL
	MOV	DH, AL			;DH为第一位小数
	MOV	AL, AH
	MOV	AH, 0
	IMUL	CH
	IDIV	CL
	MOV	DL, AL			;DL为第二位小数
	JMP	JUDGE_BX
	
DCM_MORE_THAN_ZERO:
	IDIV	CL
	;AL商，AH余数
	ADD	BYTE PTR [BX], AL
	MOV	AL, AH
	CBW
	MOV	CH, 10
	IMUL	CH
	IDIV	CL
	MOV	DH, AL			;DH为第一位小数
	MOV	AL, AH
	MOV	AH, 0
	IMUL	CH
	IDIV	CL
	MOV	DL, AL			;DL为第二位小数
	
JUDGE_BX:
	POP	BX
	CMP	BYTE PTR [BX], 0
	JE	BX_IS_ZERO
	CMP	BYTE PTR [BX], 0
	JG	BX_MORE_THAN_ZERO
	;[BX]<0
	NEG	BYTE PTR [BX]
	JMP	BX_LESS_THAN_ZERO
	
BX_IS_ZERO:
	MOV	CH, S_DCM
	MOV	S_BX, CH
	JMP	DCM_NORMAL
	
BX_MORE_THAN_ZERO:
	MOV	S_BX, 1
	CMP	S_DCM, 1
	JE	DCM_NORMAL
	SUB	BYTE PTR [BX], 1
	JMP	DCM_ABNORMAL
	
BX_LESS_THAN_ZERO:
	MOV	S_BX, -1
	CMP	S_DCM, -1
	JE	DCM_NORMAL
	SUB	BYTE PTR [BX], 1
	JMP	DCM_ABNORMAL
	
DCM_NORMAL:
	MOV	DCM, DH
	CMP	DL, 5
	JGE	DCM_NORMAL_CARRY
	JMP	END_OF_CAL_DECIMAL
	
DCM_NORMAL_CARRY:
	ADD	DCM, 1
	JMP	END_OF_CAL_DECIMAL
	
DCM_ABNORMAL:
	NEG	DH
	ADD	DH, 9
	MOV	DCM, DH
	CMP	DL, 4
	JLE	DCM_ABNORMAL_CARRY
	JMP	END_OF_CAL_DECIMAL
	
DCM_ABNORMAL_CARRY:
	ADD	DCM, 1
	JMP	END_OF_CAL_DECIMAL
	
END_OF_CAL_DECIMAL:
	POP	DX
	POP	CX
	POP	AX
	RET
CAL_DECIMAL	ENDP

OUTPUT	PROC	NEAR
	CMP	S_BX, 1
	JE	OUTPUT_BX_VALUE
	MOV	AH, 02H
	MOV	DL, '-'
	INT	21H
	
OUTPUT_BX_VALUE:
	MOV	CH, 0
	MOV	CL, BYTE PTR [BX]
HUNDRED:
	MOV	BL, 100
	MOV	AX, CX
	DIV	BL
	;AL商，AH余数
	MOV	CH, 0
	MOV	CL, AH
	CMP	AL, 0
	JE	TEN
	MOV	DL, AL
	ADD	DL, '0'
	MOV	AH, 02H
	INT	21H	
TEN:
	MOV	BL, 10
	MOV	AX, CX
	DIV	BL
	;AL商，AH余数
	MOV	CL, AH
	CMP	AL, 0
	JE	ONE
	MOV	DL, AL
	ADD	DL, '0'
	MOV	AH, 02H
	INT	21H
ONE:
	MOV	DL, CL
	ADD	DL, '0'
	INT	21H
	
	MOV	DL, '.'
	INT	21H
	
	MOV	DL, DCM
	ADD	DL, '0'
	INT	21H
	
	RET
OUTPUT	ENDP

CODE	ENDS
	END	MAIN