DATA	SEGMENT
CR_LF	DB	10, 13, '$'
SPACE_S	DB	"    $"
TIMES	DB	"times$"
NOTICE	DB	"Please enter some characters(less than or equal to 80),", 10, 13,"and end with 'Enter'", 10, 13, '$'
ALL_CHAR	DB	128 DUP(?)
AMOUNTS	DB	0
DATA	ENDS

CODE	SEGMENT
	ASSUME	CS: CODE, DS:DATA

MAIN	PROC	FAR
	PUSH	DS
	MOV	AX, 0
	PUSH 	AX
	
	MOV	AX, DATA
	MOV	DS, AX
	
	CALL	INPUT				
	CALL	ADD_A_a				;计数工作已完成，需排序
	CALL	FIND_MOST
	CALL	FIND_MOST
	CALL	FIND_MOST
	CALL	FIND_MOST
	CALL	FIND_MOST
	CALL	CRLF
	
	RET
MAIN	ENDP

CRLF	PROC	NEAR
	PUSH	AX
	PUSH	DX

	MOV	AH, 09H
	MOV	DX, OFFSET CR_LF
	INT	21H
	
	POP	DX
	POP	AX
	RET
CRLF	ENDP

SPACES	PROC	NEAR
	PUSH	AX
	PUSH	DX

	MOV	AH, 09H
	MOV	DX, OFFSET SPACE_S
	INT	21H
	
	POP	DX
	POP	AX
	RET
SPACES	ENDP

INPUT	PROC	NEAR
	PUSH	AX
	PUSH	BX
	PUSH	CX
	PUSH	DX
	
	MOV	AH, 09H
	MOV	DX, OFFSET NOTICE
	INT	21H				;输出提示语句
	
	MOV	BX, OFFSET ALL_CHAR
	MOV	CX, 0
	MOV	AH, 01
	
EVERY_CHAR:
	INT	21H
	;输入字符在AL中
	CMP	AL, 0DH
	JE	END_OF_INPUT			;如果是回车则结束INPUT
	
	MOV	DH, 0
	MOV	DL, AL
	ADD	BX, DX
	INC	BYTE PTR [BX]
	SUB	BX, DX
	
	INC	CX
	CMP	CX, 80
	JE	END_OF_INPUT
	JMP	EVERY_CHAR
	
END_OF_INPUT:
	MOV	AMOUNTS, CL
	POP	DX
	POP	CX
	POP	BX
	POP	AX
	RET
INPUT	ENDP

ADD_A_a	PROC	NEAR
	PUSH	SI
	PUSH	AX
	PUSH	BX
	PUSH	CX
	
	MOV	CX, 26
	MOV	BX, OFFSET ALL_CHAR
	MOV	SI, BX
	ADD	BX, 'a'
	ADD	SI, 'A'

ADD_ONCE:
	MOV	AH, BYTE PTR [BX]
	MOV	BYTE PTR [BX], 0		;小写置零
	ADD	BYTE PTR [SI], AH
	INC	BX
	INC	SI
	
	DEC	CX
	CMP	CX, 0
	JE	END_OF_ADD
	JMP	ADD_ONCE
	
END_OF_ADD:
	POP	CX
	POP	BX
	POP	AX
	POP	SI
	RET
ADD_A_a	ENDP

FIND_MOST	PROC	NEAR
	PUSH	AX
	PUSH	BX
	PUSH	CX
	PUSH	DX
	PUSH	SI
	
	CALL	CRLF				;换行
	MOV	CX, 128
	MOV	BX, OFFSET ALL_CHAR
	MOV	SI, BX				;SI储存最大值
	
COMPARE:
	MOV	DL, BYTE PTR [SI]
	CMP	DL, BYTE PTR [BX]
	;DL<[BX],则赋值SI为BX
	JL	CHANGE_SI
	;否则，继续COMPARE
	INC	BX
	DEC	CX
	CMP	CX, 0
	JE	END_OF_COMPARE
	JMP	COMPARE
	
CHANGE_SI:
	MOV	SI, BX
	INC	BX
	DEC	CX
	CMP	CX, 0
	JE	END_OF_COMPARE
	JMP	COMPARE
	
END_OF_COMPARE:
	;输出该字符
	MOV	AH, 02H
	MOV	DL, "'"
	INT	21H
	MOV	DX, SI
	MOV	BX, OFFSET ALL_CHAR
	SUB	DX, BX
	INT	21H
	MOV	DL, "'"
	INT	21H
	
	CALL	SPACES
	
	;输出字符出现次数
	MOV	CH,0
	MOV	CL, BYTE PTR [SI]
	CALL	OUTPUT_CX
	MOV	AH, 09H
	MOV	DX, OFFSET TIMES
	INT	21H
	
	CALL	SPACES
	
	;输出百分比
	MOV	AX, CX				;AX中储存了该字符的个数
	MOV	BL, AMOUNTS			;BL中储存了总字符的个数
	MOV	BH, 100
	MUL	BH
	DIV	BL
	;商AL 余数AH
	MOV	CH, 0
	MOV	CL, AL
	CALL	OUTPUT_CX			;输出小数点前的部分
	
	MOV	CL, AH
	MOV	AH, 02H
	MOV	DL, '.'
	INT	21H				;输出小数点
	
	MOV	AH, 0				
	MOV	AL, CL				;AX为余数
	CMP	AX, 0
	JE	IS_ZERO				;AX为0则小数部分为0
	JMP	NOT_ZERO
	
IS_ZERO:
	MOV	AH, 02H
	MOV	DL, '0'
	INT	21H
	MOV	DL, "%"
	INT	21H	
	JMP	END_OF_FIND_MOST
	
NOT_ZERO:
	;AX为余数
	MOV	BH, 10
	MUL	BH
	DIV	BL
	;商AL 余数AH
	MOV	CH, AL				;CH保存这位小数
	MOV	AL, AH
	MUL	BH
	DIV	BL
	CMP	AL, 5
	JGE	ADD_ONE
	JMP	OUTPUT_REST
	
ADD_ONE:
	INC	CH
	
OUTPUT_REST:
	MOV	AH, 02H
	MOV	DL, '0'
	ADD	DL, CH
	INT	21H
	MOV	DL, "%"
	INT	21H
	
END_OF_FIND_MOST:
	MOV	BYTE PTR [SI], 0
	POP	SI
	POP	DX
	POP	CX
	POP	BX
	POP	AX
	RET
FIND_MOST	ENDP

OUTPUT_CX	PROC	NEAR
	PUSH	AX
	PUSH	BX
	
	MOV	BH, 10
	MOV	AX, CX
	DIV	BH
	;商AL 余数AH
	MOV	BH, AH
	MOV	AH, 02H
	MOV	DL, '0'
	ADD	DL, AL
	INT	21H
	MOV	DL, '0'
	ADD	DL, BH
	INT	21H
	
	POP	BX
	POP	AX
	RET
OUTPUT_CX	ENDP

CODE	ENDS
	END	MAIN